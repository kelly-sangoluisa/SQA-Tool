Generando contexto de src...

===========================
ðŸ“ ESTRUCTURA: src
===========================

src
src/app.controller.spec.ts
src/app.controller.ts
src/app.module.ts
src/app.service.ts
src/auth
src/auth/auth.controller.ts
src/auth/auth.module.ts
src/auth/auth.service.ts
src/auth/dto
src/auth/dto/auth.dto.ts
src/auth/supabase-auth
src/auth/supabase-auth/supabase-auth.guard.spec.ts
src/auth/supabase-auth/supabase-auth.guard.ts
src/auth/types
src/auth/types/auth.types.ts
src/common
src/common/decorators
src/common/decorators/current-user.decorator.ts
src/common/decorators/public.decorator.ts
src/common/decorators/roles.decorator.ts
src/common/guards
src/common/guards/roles.guard.ts
src/main.ts
src/types
src/types/express.d.ts
src/users
src/users/dto
src/users/dto/update-role.dto.ts
src/users/entities
src/users/entities/role.entity.ts
src/users/entities/user.entity.ts
src/users/users.controller.ts
src/users/users.module.ts
src/users/users.service.ts

===========================
ðŸ§  CONTENIDO DE ARCHIVOS (texto)
===========================


--- src/app.controller.spec.ts ---

import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});

--- src/app.controller.ts ---

import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';
import { Public } from './common/decorators/public.decorator';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Public()
  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}

--- src/app.module.ts ---

import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';
import { APP_GUARD } from '@nestjs/core';

import { AppController } from './app.controller';
import { AppService } from './app.service';
import { UsersModule } from './users/users.module';
import { SupabaseAuthGuard } from './auth/supabase-auth/supabase-auth.guard';
import { RolesGuard } from './common/guards/roles.guard';
import { AuthModule } from './auth/auth.module';


@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
    }),
    TypeOrmModule.forRootAsync({
      inject: [ConfigService],
      useFactory: (configService: ConfigService) => ({
        type: 'postgres',
        url: configService.get<string>('DATABASE_URL'),
        ssl: configService.get('DB_SSL') === 'true' ? { rejectUnauthorized: false } : false,
        autoLoadEntities: true,
        synchronize: configService.get('NODE_ENV') !== 'production',
      }),
    }),
    AuthModule,
    UsersModule,
  ],
  controllers: [AppController],
  providers: [
    AppService,
    { provide: APP_GUARD, useClass: SupabaseAuthGuard },
    { provide: APP_GUARD, useClass: RolesGuard }, 
  ],
})
export class AppModule {}

--- src/app.service.ts ---

import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}

--- src/auth/auth.controller.ts ---

import { Body, Controller, Get, Post, Req, Res, UnauthorizedException } from '@nestjs/common';
import type { Response, Request } from 'express';
import { Public } from '../common/decorators/public.decorator';
import { CurrentUser } from '../common/decorators/current-user.decorator';
import { User } from '../users/entities/user.entity';
import { AuthService } from './auth.service';
import { SignInDto, SignUpDto, ForgotPasswordDto, RefreshDto, UpdatePasswordDto } from './dto/auth.dto';
import { ConfigService } from '@nestjs/config';

function cookieOpts(config: ConfigService, maxAgeMs?: number) {
  const isProd = config.get('NODE_ENV') === 'production';
  const sameSite = (config.get('COOKIE_SAMESITE') as 'lax' | 'strict' | 'none') ?? (isProd ? 'none' : 'lax');
  const secure = (config.get('COOKIE_SECURE') === 'true') || (isProd && sameSite === 'none');
  const domain = config.get<string>('JWT_COOKIE_DOMAIN') || undefined;
  return {
    httpOnly: true,
    secure,
    sameSite,
    path: '/',
    domain,
    ...(maxAgeMs ? { maxAge: maxAgeMs } : {}),
  } as const;
}

@Controller('auth')
export class AuthController {
  constructor(private readonly auth: AuthService, private readonly cfg: ConfigService) {}

  @Public()
  @Post('signup')
  async signup(@Body() dto: SignUpDto) {
    const user = await this.auth.signUp(dto.email, dto.password, dto.name, dto.redirectTo);
    return { message: 'Evaluator account created', user };
  }

  @Public()
  @Post('signin')
  async signin(@Body() dto: SignInDto, @Res({ passthrough: true }) res: Response) {
    const tokens = await this.auth.signIn(dto.email, dto.password);
    const HOUR = 60 * 60 * 1000;
    const DAYS30 = 30 * 24 * HOUR;
    res.cookie('sb-access-token', tokens.access_token, cookieOpts(this.cfg, HOUR));
    res.cookie('sb-refresh-token', tokens.refresh_token, cookieOpts(this.cfg, DAYS30));
    return { message: 'Signed in' };
  }

  @Public()
  @Post('forgot-password')
  async forgot(@Body() dto: ForgotPasswordDto) {
    await this.auth.forgotPassword(dto.email, dto.redirectTo);
    return { message: 'If the email exists, a reset link was sent' };
  }

  @Public()
  @Post('refresh')
  async refresh(@Body() dto: RefreshDto, @Req() req: Request, @Res({ passthrough: true }) res: Response) {
    const fromCookie = req.headers.cookie?.match(/(?:^|;\s*)sb-refresh-token=([^;]+)/)?.[1];
    const refreshToken = dto.refresh_token ?? (fromCookie ? decodeURIComponent(fromCookie) : undefined);
    if (!refreshToken) throw new UnauthorizedException('Missing refresh token');

    const tokens = await this.auth.refresh(refreshToken);
    const HOUR = 60 * 60 * 1000;
    const DAYS30 = 30 * 24 * HOUR;
    res.cookie('sb-access-token', tokens.access_token, cookieOpts(this.cfg, HOUR));
    res.cookie('sb-refresh-token', tokens.refresh_token, cookieOpts(this.cfg, DAYS30));
    return { message: 'Refreshed' };
  }

  @Post('update-password')
  async updatePassword(@Body() dto: UpdatePasswordDto, @Req() req: Request) {
    const sub = (req as any).user?.sub as string | undefined;
    if (!sub) throw new UnauthorizedException('No authenticated user');
    await this.auth.updatePasswordByUserId(sub, dto.new_password);
    return { message: 'Password updated' };
  }

  @Post('signout')
  async signout(@Res({ passthrough: true }) res: Response) {
    res.clearCookie('sb-access-token', cookieOpts(this.cfg));
    res.clearCookie('sb-refresh-token', cookieOpts(this.cfg));
    return { message: 'Signed out' };
  }

  @Get('me')
  me(@CurrentUser() user: User) {
    return user; // ahora viene cargado por el SupabaseAuthGuard
  }
}

--- src/auth/auth.module.ts ---

import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from '../users/entities/user.entity';
import { Role } from '../users/entities/role.entity';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';

@Module({
  imports: [ConfigModule, TypeOrmModule.forFeature([User, Role])],
  providers: [AuthService],
  controllers: [AuthController],
  exports: [AuthService],
})
export class AuthModule {}

--- src/auth/auth.service.ts ---

import { Injectable, BadRequestException, UnauthorizedException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { createClient, SupabaseClient } from '@supabase/supabase-js';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from '../users/entities/user.entity';
import { Role } from '../users/entities/role.entity';
import { Tokens } from './types/auth.types';

@Injectable()
export class AuthService {
  private supabase: SupabaseClient;
  private admin: SupabaseClient;

  constructor(
    private readonly config: ConfigService,
    @InjectRepository(User) private readonly users: Repository<User>,
    @InjectRepository(Role) private readonly roles: Repository<Role>,
  ) {
    const url = this.config.get<string>('SUPABASE_URL')!;
    this.supabase = createClient(url, this.config.get<string>('SUPABASE_ANON_KEY')!, {
      auth: { persistSession: false, autoRefreshToken: false },
    });
    this.admin = createClient(url, this.config.get<string>('SUPABASE_SERVICE_ROLE')!, {
      auth: { persistSession: false, autoRefreshToken: false },
    });
  }

  async ensureUser(email: string, name?: string, roleName: 'admin' | 'evaluator' = 'evaluator') {
    let user = await this.users.findOne({ where: { email } });
    if (user) return user;

    const role = await this.roles.findOne({ where: { name: roleName } });
    if (!role) {
      throw new BadRequestException(`Role ${roleName} not found in database`);
    }

    user = this.users.create({
      email,
      name: name ?? email.split('@')[0],
      role,
    });
    return this.users.save(user);
  }

  async signUp(email: string, password: string, name: string, redirectTo?: string) {
    const { data, error } = await this.supabase.auth.signUp({
      email,
      password,
      options: redirectTo ? { emailRedirectTo: redirectTo } : undefined,
    });
    if (error) throw new BadRequestException(error.message);

    await this.ensureUser(email, name, 'evaluator');
    return { id: data.user?.id, email: data.user?.email };
  }

  async signIn(email: string, password: string): Promise<Tokens> {
    const { data, error } = await this.supabase.auth.signInWithPassword({ email, password });
    if (error) {
      const msg = (error.message || '').toLowerCase();
      if (msg.includes('email not confirmed')) {
        throw new UnauthorizedException('Email not confirmed');
      }
      throw new UnauthorizedException(error.message);
    }
    await this.ensureUser(email);
    return {
      access_token: data.session!.access_token,
      refresh_token: data.session!.refresh_token!,
    };
  }

  async forgotPassword(email: string, redirectTo?: string) {
    const fallback = this.config.get<string>('SUPABASE_RESET_REDIRECT_TO');
    const { error } = await this.supabase.auth.resetPasswordForEmail(email, {
      redirectTo: redirectTo ?? fallback,
    });
    if (error) throw new BadRequestException(error.message);
    return { ok: true };
  }

  async refresh(refresh_token: string): Promise<Tokens> {
    const { data, error } = await this.supabase.auth.refreshSession({ refresh_token });
    if (error) throw new UnauthorizedException(error.message);
    return {
      access_token: data.session!.access_token,
      refresh_token: data.session!.refresh_token!,
    };
  }

  async updatePasswordByUserId(userId: string, newPassword: string) {
    const { error } = await this.admin.auth.admin.updateUserById(userId, {
      password: newPassword,
    });
    if (error) throw new BadRequestException(error.message);
    return { ok: true };
  }
}

--- src/auth/dto/auth.dto.ts ---

import { IsEmail, IsOptional, IsString, MinLength } from 'class-validator';

export class SignInDto {
  @IsEmail() email!: string;
  @IsString() @MinLength(6) password!: string;
}

export class SignUpDto {
  @IsEmail() email!: string;
  @IsString() @MinLength(6) password!: string;
  @IsString() name!: string;
  @IsOptional() @IsString() redirectTo?: string;
}

export class ForgotPasswordDto {
  @IsEmail() email!: string;
  @IsOptional() @IsString() redirectTo?: string;
}

export class RefreshDto {
  @IsOptional() @IsString() refresh_token?: string;
}

export class UpdatePasswordDto {
  @IsString() @MinLength(6)
  new_password!: string;
}

--- src/auth/supabase-auth/supabase-auth.guard.spec.ts ---

import { SupabaseAuthGuard } from './supabase-auth.guard';

describe('SupabaseAuthGuard', () => {
  it('should be defined', () => {
    expect(new SupabaseAuthGuard()).toBeDefined();
  });
});

--- src/auth/supabase-auth/supabase-auth.guard.ts ---

import { CanActivate, ExecutionContext, Injectable, UnauthorizedException } from '@nestjs/common';
import * as jwt from 'jsonwebtoken';
import { Request } from 'express';
import { ConfigService } from '@nestjs/config';
import { Reflector } from '@nestjs/core';
import { IS_PUBLIC_KEY } from '../../common/decorators/public.decorator';
import { UsersService } from 'src/users/users.service';

type JwtPayload = {
  sub: string;
  email?: string;
  exp?: number;
  [k: string]: any;
};

@Injectable()
export class SupabaseAuthGuard implements CanActivate {
  constructor(
    private readonly configService: ConfigService,
    private readonly reflector: Reflector,
    private readonly users: UsersService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);
    if (isPublic) return true;

    const request = context.switchToHttp().getRequest<Request>();
    const token = this.extractToken(request);
    if (!token) throw new UnauthorizedException('No token provided');

    const secret = this.configService.get<string>('SUPABASE_JWT_SECRET');
    if (!secret) throw new UnauthorizedException('JWT secret not configured');

    try {
      const payload = jwt.verify(token, secret, { algorithms: ['HS256'] }) as JwtPayload;
      (request as any).user = payload;

      if (payload?.email) {
        (request as any).currentUser = await this.users.findByEmail(payload.email);
      }

      return true;
    } catch {
      throw new UnauthorizedException('Invalid or expired token');
    }
  }

  private extractToken(req: Request): string | undefined {
    const auth = req.header('authorization');
    if (auth?.startsWith('Bearer ')) return auth.slice(7).trim();

    const cookieHeader = req.headers.cookie ?? '';
    const match = cookieHeader.match(/(?:^|;\s*)sb-access-token=([^;]+)/);
    if (match) return decodeURIComponent(match[1]);

    return undefined;
  }
}

--- src/auth/types/auth.types.ts ---

export type Tokens = {
  access_token: string;
  refresh_token: string;
};

--- src/common/decorators/current-user.decorator.ts ---

import { createParamDecorator, ExecutionContext } from '@nestjs/common';
import { User } from '../../users/entities/user.entity';

export const CurrentUser = createParamDecorator(
  (_data: unknown, ctx: ExecutionContext): User | undefined => {
    const req = ctx.switchToHttp().getRequest();
    return req.currentUser as User | undefined;
  },
);

--- src/common/decorators/public.decorator.ts ---

import { SetMetadata } from '@nestjs/common';

export const IS_PUBLIC_KEY = 'isPublic';
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);

--- src/common/decorators/roles.decorator.ts ---

import { SetMetadata } from '@nestjs/common';

export type RoleName = 'admin' | 'evaluator';
export const ROLES_KEY = 'roles';
export const Roles = (...roles: RoleName[]) => SetMetadata(ROLES_KEY, roles);

--- src/common/guards/roles.guard.ts ---

import {
  CanActivate,
  ExecutionContext,
  ForbiddenException,
  Injectable,
  UnauthorizedException,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { ROLES_KEY, RoleName } from '../decorators/roles.decorator';
import { UsersService } from '../../users/users.service';
import { User } from '../../users/entities/user.entity';

type JwtPayload = { email?: string; sub?: string; [k: string]: any };

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(
    private readonly reflector: Reflector,
    private readonly usersService: UsersService,
  ) {}

  async canActivate(ctx: ExecutionContext): Promise<boolean> {
    const requiredRoles =
      this.reflector.getAllAndOverride<RoleName[]>(ROLES_KEY, [
        ctx.getHandler(),
        ctx.getClass(),
      ]) ?? [];

    if (requiredRoles.length === 0) return true;

    const req = ctx.switchToHttp().getRequest();
    
    let user: User | null = (req.currentUser as User | undefined) ?? null;
    
    if (!user) {
      const jwtPayload = req.user as JwtPayload | undefined;
      const email = jwtPayload?.email;
      if (!email) throw new UnauthorizedException('User email not found in token');

      const dbUser = await this.usersService.findByEmail(email); 
      if (!dbUser) throw new ForbiddenException('User not registered');

      user = dbUser;
    }

    if (!user.role?.name) throw new ForbiddenException('User without role');

    if (!requiredRoles.includes(user.role.name as RoleName)) {
      throw new ForbiddenException('Insufficient role');
    }

    req.currentUser = user;
    return true;
  }
}

--- src/main.ts ---

import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import helmet from 'helmet';
import { ValidationPipe } from '@nestjs/common/pipes/validation.pipe';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  app.setGlobalPrefix('api');
  app.use(
    helmet({
      crossOriginEmbedderPolicy: false,
      contentSecurityPolicy: process.env.NODE_ENV === 'production' ? undefined : false,
    }),
  );
  
  app.useGlobalPipes(new ValidationPipe({
    whitelist: true,
    forbidNonWhitelisted: true,
    transform: true,
    transformOptions: { enableImplicitConversion: true },
  }));

  const origins = process.env.CORS_ORIGINS?.split(',').map(s => s.trim()) ?? [];
  app.enableCors({
    origin: origins,
    credentials: true,
    methods: ['GET', 'POST', 'PATCH', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization'],
  });

  const config = new DocumentBuilder()
    .setTitle('API de EvaluaciÃ³n de Calidad')
    .setDescription('DocumentaciÃ³n de la API para el sistema de evaluaciÃ³n de proyectos de software.')
    .setVersion('1.0')
    .addBearerAuth()
    .build();

  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api/docs', app, document);

  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();

--- src/types/express.d.ts ---

import { User } from '../users/entities/user.entity';

declare global {
  namespace Express {
    interface Request {
      user?: any;      
      currentUser?: User;  
    }
  }
}

--- src/users/dto/update-role.dto.ts ---

import { IsIn, IsString } from 'class-validator';

export class UpdateRoleDto {
  @IsString()
  @IsIn(['admin', 'evaluator'])
  roleName!: 'admin' | 'evaluator';
}

--- src/users/entities/role.entity.ts ---

import { Entity, PrimaryGeneratedColumn, Column } from 'typeorm';

@Entity({ name: 'roles' })
export class Role {
  @PrimaryGeneratedColumn({ name: 'role_id' })
  id: number;

  @Column({ type: 'varchar', length: 50, unique: true })
  name: string;
}

--- src/users/entities/user.entity.ts ---

import { 
  Entity, 
  PrimaryGeneratedColumn, 
  Column,
  ManyToOne,
  JoinColumn,
  CreateDateColumn,
  UpdateDateColumn,
} from 'typeorm';
import { Role } from './role.entity';

@Entity({ name: 'users' })
export class User {
  @PrimaryGeneratedColumn({ name: 'user_id' })
  id: number;

  @Column({ type: 'varchar', length: 100 })
  name: string;

  @Column({ type: 'varchar', length: 100, unique: true })
  email: string;

  @ManyToOne(() => Role, {
    eager: true,
    nullable: false,
    onDelete: 'RESTRICT',
  })
  @JoinColumn({ name: 'role_id', referencedColumnName: 'id' })
  role: Role;

  @CreateDateColumn({ name: 'created_at', type: 'timestamptz' })
  created_at: Date;

  @UpdateDateColumn({ name: 'updated_at', type: 'timestamptz' })
  updated_at: Date;
}
--- src/users/users.controller.ts ---

import { Body, Controller, Get, Param, ParseIntPipe, Patch } from '@nestjs/common';
import { UsersService } from './users.service';
import { Roles } from '../common/decorators/roles.decorator';
import { UpdateRoleDto } from './dto/update-role.dto';

@Controller('users')
export class UsersController {
  constructor(private readonly service: UsersService) {}

  @Roles('admin')
  @Get()
  getAll() {
    return this.service.findAll();
  }

  @Roles('admin', 'evaluator')
  @Get(':id')
  getOne(@Param('id', ParseIntPipe) id: number) {
    return this.service.findOne(id);
  }

  @Roles('admin')
  @Patch(':id/role')
  async updateRole(
    @Param('id', ParseIntPipe) id: number,
    @Body() dto: UpdateRoleDto,
  ) {
    return this.service.updateRole(id, dto.roleName);
  }
}

--- src/users/users.module.ts ---

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from './entities/user.entity';
import { UsersController } from './users.controller';
import { UsersService } from './users.service';
import { Role } from './entities/role.entity';

@Module({
    imports: [ TypeOrmModule.forFeature([User, Role]) ],
    controllers: [UsersController],
    providers: [UsersService],
    exports: [UsersService]
})
export class UsersModule {}

--- src/users/users.service.ts ---

import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from './entities/user.entity';
import { Role } from './entities/role.entity';

@Injectable()
export class UsersService {
  constructor(
    @InjectRepository(User) private readonly repo: Repository<User>,
    @InjectRepository(Role) private readonly rolesRepo: Repository<Role>,
  ) {}

  findAll() {
    return this.repo.find({ order: { id: 'ASC' } });
  }

  async findOne(id: number) {
    const user = await this.repo.findOne({ where: { id } });
    if (!user) throw new NotFoundException('User not found');
    return user;
  }

  async findByEmail(email: string): Promise<User | null> {
    return this.repo.findOne({ where: { email } });
  }

  async updateRole(userId: number, roleName: 'admin' | 'evaluator') {
    const user = await this.findOne(userId);
    const role = await this.rolesRepo.findOne({ where: { name: roleName } });

    if (!role) throw new BadRequestException(`Role ${roleName} not found`);

    user.role = role;
    return this.repo.save(user);
  }
}
